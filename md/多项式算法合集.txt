---
title: 多项式算法合集
date: 2019-03-14 19:32:34
tags:
- 多项式
mathjax: on
---

多项式真是神（毒）奇（瘤）！

<!--more-->

### 多项式套多项式的复杂度

先写这个是为了消除大家的TLE疑虑的。

之后会遇到这个复杂度$f(n)=f(\dfrac n2)+n\log n$

我们取最简单的$f(2^n)$
$$
\begin{align}
f(2^n)&=\sum_{i=1}^i2^ii\notag\\
&=2^nn+\sum_{i=1}^n2^{n-1}(n-1)\notag\\
&\le 2^nn+\dfrac 12\sum_{i=1}^i2^ii\notag
\end{align}
$$
于是移项后就是
$$
f(2^n)\le 2^{n+1}n
$$
这还是$O(n\log n)$！

### FFT

> $$
> c_k=\sum_{i+j=k}a_ib_j
> $$

前置知识：复数

如果我们有两个个复数$x_1=a_1i+b_1,x_2=a_2i+b_2$，它满足$|x_1|=1,|x_2|=1$，那么
$$
\begin{align}
|x_1x_2|&=|(a_1b_2+a_2b_1)i+(b_1b_2-a_1a_2)|\notag\\
&=(a_1b_2+a_2b_1)^2+(b_1b_2-a_1a_2)^2\notag\\
&=a_1^2b_2^2+a_2^2b_1^2+2a_1a_2b_1b_2+b_1^2b_2^2+a_1^2a_2^2-2a_1a_2b_1b_2\notag\\
&=a_1^2b_2^2+a_2^2b_1^2+b_1^2b_2^2+a_1^2a_2^2\notag\\
&=a_1^2(b_2^2+a_2^2)+b_1^2(a_2^2+a_1^2)\notag\\
&=a_1^2+b_1^2=1\notag
\end{align}
$$
于是如果一个复数模长为$1$，那么它的$k$次方模长都是$1$

考虑如果一个多项式有$n-1$位（最高位可以为$0$），记$\theta=\dfrac{2\pi}n,w_n^k=(i\sin\theta+\cos\theta)^k$

如果
$$
w_n^k=i\sin k\theta+\cos k\theta
$$
有
$$
\begin{align}
w_n^{k+1}&=w_n^kw_n\notag\\
&=(i\sin k\theta+\cos k\theta)(i\sin\theta+\cos\theta)\notag\\
&=i(\sin k\theta\cos\theta+\cos k\theta\sin \theta)+(\cos \theta\cos k\theta-\sin \theta\sin k\theta)\notag\\
&=i\sin(k+1)\theta+\cos(k+1)\theta\notag
\end{align}
$$
于是根据归纳法
$$
w_n^k=i\sin k\theta+\cos k\theta
$$
我们可以将$w_n^{1\dots n}$代入$f$，求这些值，称为

如果
$$
f(x)=\sum_{0\le i<2^n}a_ix^i
$$
我们可以记
$$
\begin{align}
g(x)&=\sum_{0\le 2i<2^n}a_{2i}x^i\notag\\
h(x)&=\sum_{0\le 2i<2^n}a_{2i+1}x^i\notag
\end{align}
$$
$g,h​$就都成了只有$2^{n-1}$项有值的多项式了

那么
$$
f(x)=g(x^2)+x~h(x^2)
$$
可以验算一下，发现真是这样

接下来就是一个膜法了：
$$
\begin{align}
f(w_{2^n}^k)&=g((w_{2^n}^k)^2)+x~h((w_{2^n}^k)^2)\notag\\
f(w_{2^n}^{-k})&=f(-w_{2^n}^k)=g((w_{2^n}^k)^2)-x~h((w_{2^n}^k)^2)\notag
\end{align}
$$
也就是说只要我们算出了$g((w_{2^n}^k)^2),h((w_{2^n}^k)^2)$，我们就可以快速求了！

IDFT就稍微改改，反正我也不会

#### 怎么背

只要记得FFT推导和IDFT的小改动就好了！

### NTT

和FFT差不多，把wn记作$g^{\frac{\mathrm{mod-1}}l}$即可

### inv

> $$
> f^{-1}f\equiv 1(\mathrm{mod}~x^p)
> $$

如果我们求出了
$$
f'^{-1}f\equiv 1(\mathrm{mod}~x^{\lceil\frac p2\rceil})
$$
可以得到
$$
\begin{align}
f^{-1}f&\equiv1&(\mathrm{mod}~x^{\lceil\frac p2\rceil})\notag\\
f(f^{-1}-f'^{-1})&\equiv 0&(\mathrm{mod}~x^{\lceil\frac p2\rceil})\notag\\
(f^{-1}-f'^{-1})^2&\equiv 0&(\mathrm{mod}~x^p)\notag\\
f^{-2}-2f^{-1}f'^{-1}-f'^{-2}&\equiv0&(\mathrm{mod}~x^p)\notag\\
f^{-1}-2f'^{-1}-ff'^{-2}&\equiv 0&(\mathrm{mod}~x^p)\notag\\
f^{-1}&\equiv f'^{-1}(2-ff'^{-1})&(\mathrm{mod}~x^p)\notag
\end{align}
$$
边界是$p=1$，给整数求逆即可。

### sqrt

> $$
> g^2\equiv f(\mathrm{mod}~x^p)
> $$

类似inv，如果我们求出了
$$
g'^2\equiv f(\mathrm{mod}~x^{\lceil\frac p2\rceil})\notag
$$
可以得
$$
\begin{align}
g'^2-f&\equiv 0&(\mathrm{mod}~x^{\lceil\frac p2\rceil})\notag\\
(g'^2-f)^2&\equiv 0&(\mathrm{mod}~x^p)\notag\\
(g'^2+f)^2&\equiv 4g'^2f&(\mathrm{mod}~x^p)\notag\\
(\dfrac{g'^2+f}{2g'})^2&\equiv f&(\mathrm{mod}~x^p)\notag\\
g&\equiv \dfrac{g'^2+f}{2g'}=2^{-1}(g'+\dfrac f{g'})&(\mathrm{mod}~x^p)\notag
\end{align}
$$
边界是$p=1$，可能要二次剩余算一下。

### ln

$$
\ln f=\int(\ln f)'=\int\dfrac{f'}{f}
$$

### 多项式牛顿迭代

求满足$f(g(x))=0$的$g(x)$

不会推导

结论：
$$
\begin{align}
g(x)=g_0(x)-\dfrac{f(g_0(x))}{f'(g_0(x))}\notag
\end{align}
$$


### Exp

根据牛顿迭代，有

$$
\begin{align}
g=g_0-g_0\ln g_0+g_0f\notag
\end{align}
$$

### mod&div

> $$
> f=p\times g+q
> $$

我们记$f^r$为反转$f$的系数，即$[x^a]f(x)=[x^{d_f-a}]f(x)$，其中$d_f$为$f$的最高次数

有
$$
\begin{align}
f^r&=p^r\times g^r+q^rx^{d_f-d_q}\notag\\
&\equiv p^r\times g^r&(\mathrm{mod}~x^{d_f-d_q})\notag\\
&\equiv p^r\times g^r&(\mathrm{mod}~x^{d_f-d_g+1})\notag\\
&\equiv p^r\times g^r&(\mathrm{mod}~x^{d_p+1})\notag\\
\end{align}
$$
可以用inv求$p$再反推出$q$

### 任意膜数NTT

把每个数$a$变为$2^{15}a'+a''$的形式（因为FFT精度极限比较小）

也就是
$$
\begin{align}
A\times B&=\sum_{j}(\sum_{k}a_kb_{j-k})x^j\notag\\
&=\sum_{j}(\sum_{k}(2^{30}a_k'b_{j-k}'+2^{15}a_k''b_{j-k}'+2^{15}a_k'b_{j-k}''+a_k''b_{j-k}''))x^j\notag\\
&=\sum_j(2^{30}([j]a'\times b')+2^{15}([j]a''\times b')+2^{15}([j]a'\times b'')+([j]a''\times b''))x^j\notag
\end{align}
$$
分别FFT求出即可

一共只需$8$次FFT

```cpp
...
FFT(a1,1);
FFT(b1,1);
FFT(a2,1);
FFT(b2,1);
for(int i=0;i<(1<<l);i++)
{
    c1[i]=a1[i]*b1[i];
    c2[i]=a1[i]*b2[i];
    c3[i]=a2[i]*b1[i];
    c4[i]=a2[i]*b2[i];
}
FFT(c1,-1);
FFT(c2,-1);
FFT(c3,-1);
FFT(c4,-1);
```

### FWT/FMT

~~我也不知道它们的区别~~

记$A_0$为$A_{0\dots2^{n-1}-1}$,$A_1$为$A_{2^{n-1}\dots2^n-1}$，$B,C$同理

我们不妨记对常数运算和对多项式加减为各位分别处理

我们可以发现$\mathrm{opt}$和$+$有结合率（类似$\times$）

#### $\mathrm{or}$

$$
C_0=A_0~\mathrm{or}~B_0\\
C_1=A_0~\mathrm{or}~B_1+A_1~\mathrm{or}~B_0+A_1~\mathrm{or}~B_1\\
=(A_0+A_1)~\mathrm{or}~(B_0+B_1)-C_0
$$

#### $\mathrm{and}$

$$
C_1=A_1~\mathrm{and}~B_1\\
C_0=A_0~\mathrm{and}~B_0+A_0~\mathrm{and}~B_1+A_1~\mathrm{and}~B_0\\
=(A_0+A_1)~\mathrm{and}~(B_0+B_1)-C_1
$$

#### $\mathrm{xor}$

$$
C_0=A_0~\mathrm{xor}~B_0+A_1~\mathrm{xor}~B_1\\
C_1=A_0~\mathrm{xor}~B_1+A_1~\mathrm{xor}~B_0
$$

各分两个，直接搞的话复杂度变成了暴力

然而这就有一个显然的套路

记
$$
X=(A_0+A_1)~\mathrm{xor}~(B_0+B_1)\\
Y=(A_0-A_1)~\mathrm{xor}~(B_0-B_1)\\
C_0=\dfrac{X+Y}2,C_1=\dfrac{X-Y}2
$$

#### 复杂度

有$f(2^n)=2f(2^{n-1})+O(2^n)$

也就是$O(n2^n)$（在数据规模$2^n$情况下）

#### 改成FFT那样

发现$A,B$之间互不影响，变换完后再算$C$并逆变换也是对的，就可以分层操作。

~~感觉要贴一下代码~~

```cpp
namespace fwt
{
	const int mod=998244353,i2=(mod+1)/2;
	void fwtor(long long *a,long long n,long long opt)
	{
		fr(i,0,n-1)
			for(int j=0;j<(1<<n);j+=(1<<(i+1)))
				fr(k,0,(1<<i)-1)
					a[j+k+(1<<i)]=(a[j+k+(1<<i)]+opt*a[j+k]+mod)%mod;
	}
	void fwtand(long long *a,long long n,long long opt)
	{
		fr(i,0,n-1)
			for(int j=0;j<(1<<n);j+=(1<<(i+1)))
				fr(k,0,(1<<i)-1)
					a[j+k]=(a[j+k]+opt*a[j+k+(1<<i)]+mod)%mod;
	}
	void fwtxor(long long *a,long long n,long long opt)
	{
		opt=(opt==1?1:i2);
		fr(i,0,n-1)
			for(int j=0;j<(1<<n);j+=(1<<(i+1)))
				fr(k,0,(1<<i)-1)
				{
					long long x=a[j+k],y=a[j+k+(1<<i)];
					a[j+k]=(x+y)*opt%mod;
					a[j+k+(1<<i)]=(x-y+mod)*opt%mod;
				}
	}
	const int or_tag=1,and_tag=2,xor_tag=3;
	long long _a[N],_b[N];
	void fwt(long long *c,long long *a,long long *b,long long n,long long opt)
	{
		fr(i,0,(1<<n)-1)
		{
			_a[i]=a[i];
			_b[i]=b[i];
		}
		if(opt==or_tag)
		{
			fwtor(a,n,1);
			fwtor(b,n,1);
			fr(i,0,(1<<n)-1)
				c[i]=a[i]*b[i]%mod;
			fwtor(c,n,-1);
		}
		else if(opt==and_tag)
		{

			fwtand(a,n,1);
			fwtand(b,n,1);
			fr(i,0,(1<<n)-1)
				c[i]=a[i]*b[i]%mod;
			fwtand(c,n,-1);
		}
		else if(opt==xor_tag)
		{
			fwtxor(a,n,1);
			fwtxor(b,n,1);
			fr(i,0,(1<<n)-1)
				c[i]=a[i]*b[i]%mod;
			fwtxor(c,n,-1);
		}
		fr(i,0,(1<<n)-1)
		{
			a[i]=_a[i];
			b[i]=_b[i];
		}
	}
}
```
