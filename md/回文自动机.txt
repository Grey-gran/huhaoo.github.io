---
title: 回文自动机
date: 2019-03-12 20:12:40
tags:
- string
- 回文自动机
mathjax: on
---

> 给你一个由小写拉丁字母组成的字符串$s$。我们定义$s$的一个子串的存在值为这个子串在$s$中出现的次数乘以这个子串的长度。
>
> 对于给你的这个字符串$s$，求所有回文子串中的最大存在值。

[学习论文](https://github.com/huhaoo/OIths/blob/master/string/PalindromicTree.pdf)

我语文~~没上过D~~，请见谅，如果有人愿意帮我改改，那我万分感谢

<!--more-->

### 结构

回文树大概长这样

![](回文自动机/1.png)

和其它自动机（但是它却叫『回文树』）类似的，它也是由转移边和fail组成，每个节点就是一个回文串，每个节点都可以代表所有对应它的回文子串。

因为回文串长度分为奇数和偶数，我们可以像manacher那样加入`#`（但是因为这个已经很难调了，加个岂不会调死）

但是我们发现建两棵树也没什么不妥吧。

和其它的自动机一样，fail连向的是它的后缀，但是转移边并非单纯向后加一个字符，而是在前后各加一个相同的字符（不难理解，因为要保证存的是回文串）

### 建造

我们开始是有两个节点，代表长度为$-1,0$的回文串（分别表示奇数和偶数长度），它们都是空的（也就是无代表意义），仅仅方便建造，$0$的fail指向$-1$。

类似后缀自动机，我们用增量法。

每次增加位置$p$，我们都从以上一个字符结尾的最长对应的节点开始，不断沿着fail走，直到那个节点对应以前一个位置为右端点的字符串两边字符相同，这里贴出论文中的那张图

![](回文自动机/2.png)

我们就这么找到A，然后两边添加`X`就到了现在的回文串了（即`XAX`），很显然，这个节点就是以$p$结尾的最长回文字串对应的树上节点。（同时，这个时候长度$-1$节点优势出来了，如果没有`X`能匹配条件就是同一个位置的$s_p=s_p$，就自然得到了代表字符`X`的节点。）此时要判断一下：没有这个节点，就需要新建。

然后我们连fail，从`A`出发，还是那样走，走到`B`，就是它的fail节点了。

显然，这个节点是不需新建的，`A`的前$len_B$位和后$len_B$位相同，都是`B`，前$len_B​$位的两端根据回文串对应关系，都是`X`，后面被钦定了是`X`，于是这个节点`XBX`肯定已经被包含了。

如果fail没匹配到，那么将它连向长度为$0​$的那个节点，显然这是可行的（因为这是所有节点的后缀）。

### 正确性证明

还是在图上

增加当前字符`X`，如果`XAX`的后缀没有被包含在树中，那才是不正确的，相反如果每次增加时所有后缀都在树上就是对的

然而我们找`XAX`的fail的时候，已经说明了`XBX`已经被包含在树中了

同理找`XBX`的fail时会证明一个比`XBX`短的后缀在树中

类似归纳法递归下去，所有回文串就都会在树中，于是这是正确的

因为每次只增加一个回文串，所以这是$O(n)$的

### 例题

APIO2014|luogu3649 回文串

建出树来，类似后缀自动机统计出现次数即可

[`code`](https://github.com/huhaoo/template/blob/master/%E5%9B%9E%E6%96%87%E8%87%AA%E5%8A%A8%E6%9C%BA.cpp)

```cpp
#define N 300010
long long n,t[N][30],w[N],l[N],f[N],c,ans;
char s[N];
int main()
{
	scanf("%s",s+1);
	n=strlen(s+1);
	c=2;
	f[1]=f[2]=1;
	l[1]=-1;
	long long j=2;
	s[0]='#';
	fr(i,1,n)
	{
		while(s[i-l[j]-1]!=s[i])
			j=f[j];
		if(!t[j][s[i]-'a'])
		{
			c++;
			long long k=j;
			l[c]=l[k]+2;
			k=f[k];
			while(s[i-l[k]-1]!=s[i])
				k=f[k];
			f[c]=t[k][s[i]-'a'];
			if(!f[c])
				f[c]=2;
			t[j][s[i]-'a']=c;
		}
		j=t[j][s[i]-'a'];
		w[j]++;
	}
	fd(i,c,1)
		w[f[i]]+=w[i];
	fr(i,1,c)
		ans=max(ans,l[i]*w[i]);
	printf("%lld\n",ans);
	return 0;
}
```

