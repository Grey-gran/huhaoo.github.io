---
title: 一些技巧与总结
date: 2019-08-08 21:41:32
mathjax: on
---

### 前言

~~我也不知道你怎么进来的~~

由于博客大多按心情写，所以有些博客质量不高，前后风格也不太一样，所以就在这里写一些简要说明~~还有少量技巧~~

### 数学相关

#### 计数、概率与期望相关

1. 对于地位相同的一组变量，如果要求一个值的期望，可以**求**所有值的**和**然后**取平均值**

2. 一个固定的区间$A$与一个长度固定的区间$B$的交的长度是关于$B$左端点的分段一次函数，它的二维差分至多有$4$个位置有值，处理大量区间相交长度和时很好处理

3. 如果给定一组变量，每个都在一个区间内任取整值，并对他们的和做些处理，不妨容斥成只有下界，然后就有：
$$
   \begin{align}
   &\sum_{a_1\ge l_1}\sum_{a_2\ge l_2}\dots\sum_{a_n\ge l_n}f(a_1+a_2+\dots+a_n)\notag\\
   =&\sum_{s\ge \sum l}f(s){s-\sum l+n-1\choose n-1}
   \end{align}
$$
   考虑到$s-\sum l$可以任意分配给$a$

4. 数位DP可以从低位往高位DP，记$f_{i,0}$表示在第$i$位且$\le limit$，$f_{i,1}$表示大于，这样转移会变得方便

5. 数位DP只要想的话，可以状压和维护进位处理多个数，不过一般会不好调，$4$的技巧可以用上。

6. 如果考虑$n$个变量在$[1,m]$内取值的所有情况贡献和，且贡献仅仅与$n$个变量两两是否相等（可以有等于/不等于某个值的条件）有关（并且范围保证$3^nm$不大），可以考虑DP：$f_{s,t}$表示值$\le t$的集合为$s$，每次转移就枚举等于$t$的集合，这样是$3^nm$的

7. 容斥可以通过考虑一个状态对每个记数器的贡献，通过调整计数器的权值来只记录有效状态

8. 可以尝试把容斥系数变为二项式系数，然后二项式反演可以卷积求解（一般来说，恰好转化为至少好做些）

#### 博弈论

1. 对于求最优情况下最终值的题，可以先**二分**这个值，然后就得到一个简化后的问题：

   最终能否走到对后手不利的状态（对先手来说比二分的答案优）

   这是一个二分图，可以看`图论/二分图/1`来求解

#### 高斯消元

1. 部分无解不代表需要求的无解，可以**dfs**出需要求的变量要用到哪些变量然后只用这些变量

#### 数论

1. 
$$
\gcd(i,j)=\sum_{d|\gcd(i,j)}\phi(d)=\sum_{d|i,d|j}\phi(d)
$$

### 图论

#### 二分图

1. 判断从某个点一直走到不重复的点（直到它能走到的点都被走了）是否一定能走到对面，只需判断这个点有出边并且最大匹配和除去这个点的最大匹配是否不相等（即**这个点必须包含在所有可能的最大匹配中**）

   证明显然：如果有一个'最大匹配'不包括这个点，那么只要有一种方案能到对面时中止，那么将这种方案在'最大匹配'上取反，那么最大匹配数会加一（和匈牙利算法流程相同）

#### 网络流

1. ~~SPFA已死~~，可以用primal-dual method转化为dijkstra

   一句话讲不清，具体看[代码](https://github.com/huhaoo/code/blob/template/%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%9C%80%E5%A4%A7%E6%B5%81.cpp)

   做法就是边权加上$h_u-h_v$，每跑一次就给$h$加上$d$，用加上后的$h$表示$d$

#### other

1. 当$M$表示一个图的邻接矩阵时$M^n_{i,j}$表示$i$到$j$的长度为$n$的任意游走条数

### other

1. 数据量大概在$5\times 10^6$字符就可以开始考虑读入优化了

2. 哈曼顿距离维护时可以转化为切比雪夫距离$(x,y)\rightarrow (x+y,x-y)$

### 数据结构

1. 用bitset进行区间0/1操作可以考虑维护全为$0/1$的段，通过不断合并相交段来降低复杂度

2. 线段树父亲标记时间一般比儿子晚

### 贪心

1. 可以先写出费用流，然后通过快速维护当前最小费用来实现贪心

2. sort需要保证以下性质：

   1. 非自反性$a\not< a$

   2. 非对称性$a<b \Rightarrow b\not< a$

   3. 传递性$a<b,b<c\Rightarrow a<c$

   4. 不可比的传递性$a\not< b,b\not< a,b\not< c,c\not< b\Rightarrow a\not< c,c\not< a$

   于是需要注意$a\le b\le c$时，可能会有$c<a$，于是需要注意$=$的情况

   即$f(x,y)<f(y,x)$之类的函数要额外考虑一下

3. 邻项交换式子中，如果有$\max(a,c)\le \max(b,c)$，那么可以变为$a\le b$

   考虑到$a>c$，那么就是$a\le \max(b,c)$，如果$b<c$，或者$b\ge c$，发现都等同于$a\le b$

   否则，就是$c\le \max(b,c)$，当$b>c$时两个命题都是对的，否则交不交换不影响

   同样的，$\min$同理

### 构造，交互，提答类

（基本上这类都需要构造一种方案出来）

1. 构造题可以想着把若干个子问题拼起来。

   比如说CF1208C，可以把若干个$4\times 4$的子数组拼起来（可以直接$0+4k\sim 15+4k$依次填到这个数组，然后它们异或和为$0$）

### 经典题

#### 三/四元环计数

   三元环可以按度数从小到大顺序（如果相等任意排序，记$r_i$为$i$的名次）枚举$i,j,k$，如果是环就统计

   四元环可以枚举$i$，然后找到$j,k$，满足$r_i<r_j,r_k$，给$i,j,k$的答案加上$k$的经过次数，然后给$k$的经过次数$+1$，发现这样就统计好了四元环的$(a,b,c,d)$中$a,c,d$部分，然后可以在清空$k$经过次数的时候统计好$b$即可

可以看代码：

```cpp
for(int i=1;i<=n;i++)
{
	for(auto j:t[i])if(cmp(i,j))
		for(auto k:t[j])if(cmp(i,k))
		{
			r4[i]+=s[k];r4[j]+=s[k];r4[k]+=s[k];
			s[k]++;
		}
	for(auto j:t[i])if(cmp(i,j))
		for(auto k:t[j])if(cmp(i,k))
		{
			s[k]--;
			r4[j]+=s[k];
		}
}
```

#### 区间内带权区间并

也就是一个数组，元素为区间，每次询问这个数组的一段区间，求所有元素（即一些区间）的并

可以先把询问按右端点从小到大排序，在第$i$个位置加入区间$[l_i,r_i]$，显然询问包含$i$时（也就是后面的且左端点小于等于$i$的），这就在答案内，我们可以先删掉原来的贡献，然后在$i$位置加入新的贡献

```cpp
set<seg>::iterator split(int p)
{
	set<seg>::iterator a=s.lower_bound(seg(p,p,0));
	if(a==s.end())
		return a;
	int l=a->l,r=a->r,c=a->c;
	if(p<=l)
		return a;
	s.erase(a);
	s.insert(seg(l,p-1,c));
	return s.insert(seg(p,r,c)).first;
}
void add(int p,i64 v)
{
	while(p)
	{
		b[p]+=v;
		p-=p&(-p);
	}
}
i64 query(int p)
{
	i64 r=0;
	while(p<=m)
	{
		r+=b[p];
		p+=p&(-p);
	}
	return r;
}
void insert(int l,int r,int c)
{
	set<seg>::iterator i1,i2;
	i2=split(r+1);
	i1=split(l);
	while(i1!=i2)
	{
		add(i1->c,-(A[i1->r]-A[i1->l-1]));
		i1=s.erase(i1);
	}
	add(c,A[r]-A[l-1]);
	s.insert(seg(l,r,c));
}
void run()
{
	sort(Q+1,Q+q+1,cmp);
	int I=1,J=1;
	fr(i,1,m)
	{
		while(c[I]==i)
		{
			insert(l[I],r[I],i);
			I++;
		}
		while(Q[J].r==i)
		{
			ans[Q[J].id]=query(Q[J].l);
			J++;
		}
	}
}
```

其中$l,r$代表区间左右端点，$c$表示这个区间的位置（如果可以一个位置有多个区间）

#### 快速乘法逆元

快速求$n$个数$a_{1\dots n}$的乘法逆元

可以先求它们前缀积$s_{1\dots n}$，然后求$s_n$逆元，就是所有数积的逆元，然后依次乘$a_{n\dots 1}$，就得到所有的前缀逆元，乘以上一个前缀积即可

```cpp
void getinv(i64 *a,i64 *inv,i64 n)
{
	inv[1]=a[1];
	fr(i,2,n)
		inv[i]=inv[i-1]*a[i]%mod;
	inv[n]=power(inv[n],mod-2,mod);
	fd(i,n,2)
	{
		//此时inv[i]为1..i逆元，inv[i-1]为1..i乘积
		i64 I=inv[i];
		inv[i]=inv[i]*inv[i-1]%mod;
		inv[i-1]=I*a[i]%mod;
	}
}
```
